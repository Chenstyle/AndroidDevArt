### 15.1 Android的性能优化方法

本节介绍了一些有效的性能优化方法，主要内容包括布局优化、绘制优化、内存泄露优化、响应速度优化、ListView优化、Bitmap优化、线程优化以及一些性能优化建议，在介绍响应速度优化的同事还介绍了ANR日志的分析方法。

#### 15.1.1 布局优化

布局优化的思想很简单，就是尽量减少布局文件的层级，这个道理是很浅显的，布局中层数少了，这就意味着Android绘制时的工作量少了，那么程序的性能自然就高了。

如何进行布局优化呢？首先删除布局中无用的控件和层级，其次有选择的使用性能较低的ViewGroup，比如RelativeLayout。如果布局中既可以使用LinearLayout也可以使用RelativeLayout，那么就采用LinearLayout，这是因为RelativeLayout的功能比较复杂，它的布局国成永恒需要花费更多的CPU时间。FrameLayout和LinearLayout一样都是一种简单高效的ViewGroup，因此可以考虑使用它们，但是很多时候单纯通过一个LinarLayout或者FrameLayout无法实现产品效果，需要通过嵌套的方式来完成。这种情况下还是建议采用RelativeLayout，因为ViewGroup的嵌套就相当于增加了布局的层级，同样会降低程序的性能。

布局优化的另外一种手段是采用<include>标签、<merge>标签和ViewStub。<include>标签主要用于布局重用，<merge>标签一般和<include>配合使用，它可以降低减少布局的层级，而ViewStub则提供了按需加载的功能，当需要时才会将ViewStub中的布局加载到内存，这提高了程序的初始化效率，下面分别介绍它们的使用方法。

**<include>标签**

<include>标签可以将一个指定的布局文件加载到当前的布局文件中，如下所示。

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/app_bg"
    android:gravity="center_horizontal"
    >
    
    <include layout="@layout/titlebar" />
    
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="@string/text"
        android:padding="5dp"
        />
    
</LinearLayout>
```

上面的代码中，@layout/titlebar指定了另外一个布局文件，通过这种方式就不用把titlebar这个布局文件的内容再重复写一遍了，这就是<include>的好处。<include>标签只支持以android:layout_开头的属性，比如android:layout_width、android:layout_height，其他属性是不支持的，比如android:background。当然，android:id这个属性是个特例，如果<include>指定了这个id属性，同时被包含的布局文件的根元素也指定了id属性，那么以<include>指定的id属性为准。需要注意的是，如果<include>标签指定了android:layout_*这种属性，那么要求android:layout_width和android:layout_height必须存在，否则其他android:layout_*形式的属性无法生效，下面是一个指定了android:layout_*属性的示例。

```xml
<include
    android:id="@+id/new_title"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    layout="@layout/title"
    />
```

**<merge>标签**

<merge>标签一般和<include>标签一起使用从而减少布局的层级。在上面的示例中，由于当前布局是一个竖直方向的LinearLayout，这个时候如果被包含的布局文件中也采用了竖直方向的LinearLayout，那么显然被包含的布局文件中国的LinearLayout是多余的，通过<merge>标签就可以去掉多余的那一层LinearLayout，如下所示。

```xml
<merge xmlns:android="http://schemas.android.com/apk/res/android">
    
    <Button
        android:layout_width="wrap_content"
        androdi:layout_height="wrap_content"
        android:text="@string/one"
        />
    
    <Button
        android:layout_width="wrap_content"
        androdi:layout_height="wrap_content"
        android:text="@string/two"
        />
</merge>
```

**ViewStub**

ViewStub集成了View，它非常轻量级且宽/高都是0，因此它本身不参与任何的布局和绘制过程。ViewStub的意义在于按需加载所需的布局文件，在实际开发中，有很多布局文件在正常情况下不会显示，比如网络异常时的界面，这个时候就没有必要再整个界面初始化的时候将其加载出来，通过ViewStub就可以做到在使用的时候再加载，提高了程序初始化时的性能。下面是一个ViewStub的示例：

```xml
<ViewStub
    android:id="@+id/stub_import"
    android:inflatedId="@+id/panel_import"
    android:layout="@layout/layout_network_error"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_gravity="bottom"
    />
```

其中stub_import是ViewStub的id，而panel_import是layout/layout_network_error这个布局的根元素id。如做到按需加载呢？在需要加载ViewStub中的布局时，可以按照如下两种方式进行：

```Java
((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE);
```

或者

```Java
View importPannel = ((ViewStub) findViewById(R.id.stub_import)).inflate();
```

当ViewStub通过setVisibility或者inflate方法加载后，ViewStub就会被它内部的布局替换掉，这个时候ViewStub就不再是整个布局结构中的一部分。另外，目前ViewStub还不支持<merge>标签。

#### 15.1.2 绘制优化

绘制优化是值View的onDraw方法要避免执行大量的操作，这主要体现在两个方面。

首先，onDraw中不要创建新的局部对象，这是因为onDraw方法可能会被频繁调用，这样就会在一瞬间产生大量的临时对象，这不仅占用了过多的内存而且还会导致系统更加频繁gc，降低了程序的执行效率。

另外一方面，onDraw方法中不要做耗时的任务，也不能执行成千上万次的循环操作，尽管每次循环都很轻量级，但是大量的循环仍然十分抢占CPU的时间片，这会造成View的绘制过程不流畅。按照Google官方给出的性能优化典范中的标准，View的绘制帧率保证60fps是最佳的，这就要求每帧的绘制时间不超过16ms（16ms = 1000 / 60），虽然程序很难保证16ms这个时间，但是尽量降低onDraw方法的复杂度总是切实有效的。

#### 15.1.3 内存泄露优化

内存泄露在开发过程中是一个需要重视的问题，但是由于内存泄露问题对开发人员的经验和开发意识有较高的要求，因此这也是开发人员最容易犯的错误之一。内存泄露的优化分为两个方面，一方面是在开发过程中避免写出有内存泄露的代码，另一方面是通过一些分析工具比如MAT来找出潜在的内存泄露继而解决。本节主要介绍一些常见的内存泄露放入例子，通过这些例子读者可以很好地理解内存泄露的发生场景并基类规避内存泄露的经验。关于如何通过工具分析内存泄露将在15.2节中专门介绍。

**场景1：静态变量导致的内存泄露**

下面这种情形是一种最简单的内存泄露，相信读者都不会这么干，下面的代码将导致Activity无法正常销毁，因为静态变量sContext引用了它。

```Java
public class MainActivity extends Activity {
    private static final String TAG = "MainActivity";
    
    private static Context sContext;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        sContext = this;
    }
}
```

上面的代码也可以改造一下，如下所示。sView是一个静态变量，它内部持有了当前Activity，所以Activity仍然无法释放，估计读者也都明白。

```Java
public class MainActivity extends Activity {
    private static final String TAG = "MainActivity";
    
    private static View sView;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        sView = new View(this);
    }
}
```

**场景2：单例模式导致的内存泄露**

静态变量导致的内存泄露都太过于明显，相信读者都不会犯这种错误，而单例模式所带来的内存泄露是我们容易忽视的，如下所示。首先提供一个单例模式的TestManager，TestManager可以接收外部的注册并将外部的监听器存储起来。

```Java
public class TestManager {
    
    private List<OnDataArrivedListener> mOnDataArrivedListeners = new ArrayList<>();
    
    private static class SingletonHolder {
        public static final TestManager INSTANCE = new TestManager();
    }
    
    private TestManager(){}
    
    public static TestManager getInstance() {
        return SingletonHolder.INSTANCE;
    }
    
    public synchronized void registerListener(OnDataArrivedListener listener) {
        if (!mOnDataArrivedListeners.contains(listener)) {
            mOnDataArrivedListeners.add(listener);
        }
    }
    
    public synchronized void unregisterListener(OnDataArrivedListener listener) {
        mOnDataArrivedListeners.remove(listener);
    }
    
    public interface OnDataArrivedListener {
        public void onDataArrived(Object data);
    }
}
```

接着再让Activity实现OnDataArrivedListener接口并向TestManager注册监听，如下所示。下面的代码由于缺少解注册的操作所以会引起内存泄露，泄露的原因是Activity的对象被单例模式的TestManager所持有，而单例模式的特点是其生命周期和Application保持一致，因此Activity对象无法被及时释放。

```Java
protected void onCreate(Bundle savedInstanceState) {
    
}
```